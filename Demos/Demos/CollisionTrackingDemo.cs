using System;
using System.Numerics;
using BepuUtilities;
using BepuPhysics;
using DemoContentLoader;
using DemoRenderer;
using BepuPhysics.Collidables;
using DemoUtilities;
using DemoRenderer.UI;
using BepuPhysics.CollisionDetection;
using BepuUtilities.Collections;
using BepuUtilities.Memory;
using System.Runtime.CompilerServices;
using BepuPhysics.Constraints;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Demos.Demos;

/// <summary>
/// Shows how to store out collision information provided in <see cref="INarrowPhaseCallbacks"/> for later analysis, 
/// and how to use it to implement something like collision events without imposing the weird control flow that events imply.
/// </summary>
/// <remarks>
/// This implementation focuses more on simplicity than performance.
/// It's not too slow, but if you run into bottlenecks, be advised that you can make it faster!
/// </remarks>
public class CollisionTrackingDemo : Demo
{
    /// <summary>
    /// Refers to a collidable, or a child within a collidable.
    /// </summary>
    /// <remarks>This contact tracker allows the children of compounds to be tracked, so it's not enough to only store a <see cref="CollidableReference"/>.
    /// That would only permit top-level pair analysis.</remarks>
    public struct ContactSource : IEqualityComparerRef<ContactSource>, IEquatable<ContactSource>
    {
        /// <summary>
        /// Collidable associated with this listener.
        /// </summary>
        public CollidableReference Collidable;
        /// <summary>
        /// Child index within the collidable associated with this listener, if any. -1 if the listener is associated with the entire collidable.
        /// </summary>
        public int ChildIndex;

        public bool Equals(ref ContactSource a, ref ContactSource b) => a.Collidable == b.Collidable && a.ChildIndex == b.ChildIndex;
        public int Hash(ref ContactSource item) => (int)(item.Collidable.Packed ^ uint.RotateLeft((uint)item.ChildIndex, 16));
        public bool Equals(ContactSource other) => Equals(ref this, ref other);
        public override bool Equals(object obj) => obj is ContactSource source && Equals(source);
        public override int GetHashCode() => Hash(ref this);
        public static bool operator ==(ContactSource left, ContactSource right) => left.Equals(right);
        public static bool operator !=(ContactSource left, ContactSource right) => !(left == right);

        public static implicit operator ContactSource(CollidableReference collidable) => new() { Collidable = collidable, ChildIndex = -1 };
    }


    /// <summary>
    /// Stores contacts generated by the narrow phase for a pair.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public struct PairCollision
    {
        /// <summary>
        /// The other collidable (and if applicable, child) associated with this pair.
        /// </summary>
        [FieldOffset(0)]
        public ContactSource Other;
        /// <summary>
        /// Stores whether <see cref="Other"/> is stored in the first slot of the collision pair. True if it is, false if it isn't.
        /// This matters for interpreting the contact data: by convention, the contact offset is relative to collidable A, and the normal points from B to A.
        /// </summary>
        [FieldOffset(8)]
        public bool OtherIsPairA;
        /// <summary>
        /// Contacts generated by the narrow phase.
        /// </summary>
        /// <remarks>We're making use of the <see cref="NonconvexContactManifold"/> type here because it's able to store both nonconvex manifolds and convex manifolds.
        /// Within the callbacks, we convert convex manifolds into nonconvex manifolds by rearranging data; that way, post-analysis doesn't need to worry about the manifold type.</remarks>
        [FieldOffset(12)]
        public NonconvexContactManifold Contacts;
    }



    /// <summary>
    /// Tracks collisions for a set of collidables (or their children).
    /// </summary>
    public class CollisionTracker
    {
        IThreadDispatcher dispatcher;
        BufferPool pool;

        public CollisionTracker(BufferPool pool, IThreadDispatcher dispatcher)
        {
            this.pool = pool;
            this.dispatcher = dispatcher;
            Tracked = new QuickDictionary<ContactSource, TrackedContacts, ContactSource>(16, pool);
        }

        public struct TrackedContacts
        {
            /// <summary>
            /// Holds all contacts reported about a tracked object by narrow phase callbacks for the timestep before the most recent timestep.
            /// </summary>
            public QuickList<PairCollision> PreviousCollisions;
            /// <summary>
            /// Holds all contacts reported about a tracked object by narrow phase callbacks for the most recent timestep.
            /// </summary>
            public QuickList<PairCollision> Collisions;

            public TrackedContacts(BufferPool pool)
            {
                //For simplicity, we'll initialize all the contact storage with a fixed size. It'll grow over time if more collisions per tracked object are detected.
                //Some kind of compaction would be easy to add- just iterate over all tracked objects and call Compact on these lists.
                //(Or just part of them, incrementally! Probably better to avoid excess resizes!)
                Collisions = new QuickList<PairCollision>(8, pool);
                PreviousCollisions = new QuickList<PairCollision>(8, pool);
            }

            public void Dispose(BufferPool pool)
            {
                PreviousCollisions.Dispose(pool);
                Collisions.Dispose(pool);
            }
        }

        /// <summary>
        /// Maps tracked objects to the contacts associated with them.
        /// </summary>
        public QuickDictionary<ContactSource, TrackedContacts, ContactSource> Tracked;

        /// <summary>
        /// Adds a collidable (or its child) to the collision tracker. Collisions associated with it will be included for queries.
        /// </summary>
        /// <param name="target">Collidable (or child) to track.</param>
        /// <exception cref="ArgumentException">Triggered if the collidable or child is already present.</exception>
        public void Track(ContactSource target)
        {
            if (Tracked.ContainsKey(target))
                throw new ArgumentException("Object already tracked.");
            Tracked.Add(target, new TrackedContacts(pool), pool);
        }

        /// <summary>
        /// Removes a listener from the tracker.
        /// </summary>
        /// <param name="target">Collidable (or child) to untrack.</param>
        /// <exception cref="ArgumentException">Triggered if the collidable or child is not present.</exception>
        public void Untrack(ContactSource target)
        {
            if (!Tracked.ContainsKey(target))
                throw new ArgumentException("Object is not tracked.");
            Tracked.GetTableIndices(ref target, out var tableIndex, out var elementIndex);
            ref var contacts = ref Tracked.Values[elementIndex];
            contacts.PreviousCollisions.Dispose(pool);
            contacts.Collisions.Dispose(pool);
            Tracked.FastRemove(tableIndex, elementIndex);
        }

        //The INarrowPhaseCallbacks are invoked from multiple threads and are performance sensitive.
        //We want to do as little as possible, so rather than locking and trying to modify the final storage directly,
        //just create per-worker caches that get flushed at the end.

        /// <summary>
        /// Stores a single tracked result in a worker cache to later be flushed.
        /// </summary>
        struct WorkerPairContacts
        {
            public ContactSource Self;
            public PairCollision Collision;
        }

        /// <summary>
        /// Stores contacts for listeners reported by callbacks to a particular thread.
        /// </summary>
        Buffer<QuickList<WorkerPairContacts>> workerCaches;

        public void PrepareForNextTimestep()
        {
            workerCaches = new Buffer<QuickList<WorkerPairContacts>>(dispatcher.ThreadCount, pool);
            for (int i = 0; i < workerCaches.Length; ++i)
            {
                workerCaches[i] = new QuickList<WorkerPairContacts>(512, dispatcher.GetThreadMemoryPool(i));
            }
        }

        /// <summary>
        /// Flushes all collisions found in the previous timestep into efficient storage for queries.
        /// </summary>
        public void Flush()
        {
            //Flip the caches for each listener and clear out the now-current set for accumulation.
            for (int i = 0; i < Tracked.Count; ++i)
            {
                ref var listenerContacts = ref Tracked.Values[i];
                BepuPhysics.Helpers.Swap(ref listenerContacts.PreviousCollisions, ref listenerContacts.Collisions);
                listenerContacts.Collisions.Count = 0;
            }

            //Flush the worker caches into the main storage and dispose the caches.
            for (int i = 0; i < workerCaches.Length; ++i)
            {
                ref var cache = ref workerCaches[i];
                for (int j = 0; j < cache.Count; ++j)
                {
                    ref var entry = ref cache[j];
                    Tracked.GetTableIndices(ref entry.Self, out _, out var elementIndex);
                    Tracked.Values[elementIndex].Collisions.Add(entry.Collision, pool);
                }
                //The worker cache memory must be returned to the thread pool, not the main pool!
                cache.Dispose(dispatcher.GetThreadMemoryPool(i));
            }
            workerCaches.Dispose(pool);
        }

        private void ReportContacts<TContacts>(int workerIndex, ContactSource self, ContactSource other, bool otherIsA, ref TContacts contacts) where TContacts : unmanaged, IContactManifold<TContacts>
        {
            if (Tracked.ContainsKey(self))
            {
                //A is a listener, add it.            
                ref var pairContacts = ref workerCaches[workerIndex].Allocate(dispatcher.GetThreadMemoryPool(workerIndex));
                pairContacts.Self = self;
                pairContacts.Collision.Other = other;
                pairContacts.Collision.OtherIsPairA = otherIsA;
                if (typeof(TContacts) == typeof(ConvexContactManifold)) //This is a JIT-time constant.
                {
                    //The pairContacts representation just uses a NonconvexContactManifold for simplicity- we can just rearrange convex contacts to fit.
                    //(Without doing this, the post-analysis would constantly have to check an "IsConvex" flag and so forth. It would be quite stinky.)
                    ref var convex = ref Unsafe.As<TContacts, ConvexContactManifold>(ref contacts);
                    for (int i = 0; i < contacts.Count; ++i)
                    {
                        ref var targetContact = ref Unsafe.Add(ref pairContacts.Collision.Contacts.Contact0, i);
                        convex.GetContact(i, out targetContact.Offset, out targetContact.Normal, out targetContact.Depth, out targetContact.FeatureId);
                    }
                    pairContacts.Collision.Contacts.Count = contacts.Count;
                    pairContacts.Collision.Contacts.OffsetB = convex.OffsetB;
                }
                else
                {
                    pairContacts.Collision.Contacts = Unsafe.As<TContacts, NonconvexContactManifold>(ref contacts);
                }
            }
        }

        /// <summary>
        /// Notifies the tracker of a collision between collidable children.
        /// </summary>
        /// <param name="collidableA">First collidable in the pair.</param>
        /// <param name="childIndexA">Child index associated with the first collidable in the pair.</param>
        /// <param name="collidableB">Second collidable in the pair.</param>
        /// <param name="childIndexB">Child index associated with the second collidable in the pair.</param>
        /// <param name="workerIndex">Index of the worker invoking this callback.</param>
        /// <param name="contacts">Contacts reported in the callback.</param>
        public void ReportChildContacts(CollidableReference collidableA, int childIndexA, CollidableReference collidableB, int childIndexB, int workerIndex, ref ConvexContactManifold contacts)
        {
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            var a = new ContactSource { Collidable = collidableA, ChildIndex = childIndexA };
            var b = new ContactSource { Collidable = collidableB, ChildIndex = childIndexB };
            ReportContacts(workerIndex, a, b, false, ref contacts);
            ReportContacts(workerIndex, b, a, true, ref contacts);
        }


        /// <summary>
        /// Notifies the tracker of a collision between collidables.
        /// </summary>
        /// <typeparam name="TManifold">Type of the manifold being reported.</typeparam>
        /// <param name="collidableA">First collidable in the pair.</param>
        /// <param name="collidableB">Second collidable in the pair.</param>
        /// <param name="workerIndex">Index of the worker invoking this callback.</param>
        /// <param name="contacts">Contacts reported in the callback.</param>
        public void ReportContacts<TManifold>(CollidableReference collidableA, CollidableReference collidableB, int workerIndex, ref TManifold contacts) where TManifold : unmanaged, IContactManifold<TManifold>
        {
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            var a = new ContactSource { Collidable = collidableA, ChildIndex = -1 };
            var b = new ContactSource { Collidable = collidableB, ChildIndex = -1 };
            ReportContacts(workerIndex, a, b, false, ref contacts);
            ReportContacts(workerIndex, b, a, true, ref contacts);
        }

    }

    /// <summary>
    /// Callbacks invoked by the simulation's narrow phase.
    /// In this demo, we'll collect all contact data associated with tracked objects for later processing.
    /// </summary>
    public unsafe struct CollisionTrackingCallbacks : INarrowPhaseCallbacks
    {
        CollisionTracker collisionTracker;
        public CollisionTrackingCallbacks(CollisionTracker collisionTracker)
        {
            this.collisionTracker = collisionTracker;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AllowContactGeneration(int workerIndex, CollidableReference a, CollidableReference b, ref float speculativeMargin)
        {
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AllowContactGeneration(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB)
        {
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe bool ConfigureContactManifold<TManifold>(int workerIndex, CollidablePair pair, ref TManifold manifold, out PairMaterialProperties pairMaterial) where TManifold : unmanaged, IContactManifold<TManifold>
        {
            pairMaterial.FrictionCoefficient = 1f;
            pairMaterial.MaximumRecoveryVelocity = 2f;
            pairMaterial.SpringSettings = new SpringSettings(30, 1);
            collisionTracker.ReportContacts(pair.A, pair.B, workerIndex, ref manifold);
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ConfigureContactManifold(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB, ref ConvexContactManifold manifold)
        {
            collisionTracker.ReportChildContacts(pair.A, childIndexA, pair.B, childIndexB, workerIndex, ref manifold);
            return true;
        }

        public void Initialize(Simulation simulation)
        {
        }

        public void Dispose()
        {
        }

    }

    /// <summary>
    /// Tracks a particle created by a collision.
    /// </summary>
    struct ContactResponseParticle
    {
        public Vector3 Position;
        public float Age;
        public Vector3 Normal;
    }
    QuickList<ContactResponseParticle> particles;

    CollisionTracker collisionTracker;


    public override void Initialize(ContentArchive content, Camera camera)
    {
        camera.Position = new Vector3(0, 8, -20);
        camera.Yaw = MathHelper.Pi;

        particles = new QuickList<ContactResponseParticle>(8, BufferPool);

        collisionTracker = new CollisionTracker(BufferPool, ThreadDispatcher);
        Simulation = Simulation.Create(BufferPool, new CollisionTrackingCallbacks(collisionTracker), new DemoPoseIntegratorCallbacks(new Vector3(0, -10, 0)), new SolveDescription(8, 1));


        var listenedBody1 = Simulation.Bodies.Add(BodyDescription.CreateConvexDynamic(new Vector3(0, 5, 0), 1, Simulation.Shapes, new Box(1, 2, 3)));
        collisionTracker.Track(Simulation.Bodies[listenedBody1].CollidableReference);

        var listenedBody2 = Simulation.Bodies.Add(BodyDescription.CreateConvexDynamic(new Vector3(0.5f, 10, 0), 1, Simulation.Shapes, new Capsule(0.25f, 0.7f)));
        collisionTracker.Track(Simulation.Bodies[listenedBody2].CollidableReference);


        Simulation.Statics.Add(new StaticDescription(new Vector3(0, -0.5f, 0), Simulation.Shapes.Add(new Box(30, 1, 30))));
        Simulation.Statics.Add(new StaticDescription(new Vector3(0, 3, 15), Simulation.Shapes.Add(new Box(30, 5, 1))));
    }

    static bool IsTouching(NonconvexContactManifold contacts)
    {
        for (int i = 0; i < contacts.Count; ++i)
        {
            //This may look a bit odd: it's a legacy issue from before static abstracts existed. Expect it to change soon!
            if (contacts.GetDepth(ref contacts, i) >= 0)
            {
                return true;
            }
        }
        return false;
    }

    void AddParticle(Vector3 contactOffset, Vector3 contactNormal, CollidableReference firstCollidableInPair)
    {
        ref var particle = ref particles.Allocate(BufferPool);

        //Contact data is calibrated according to the order of the pair, so using A's position is important.
        particle.Position = contactOffset + (firstCollidableInPair.Mobility == CollidableMobility.Static ?
            new StaticReference(firstCollidableInPair.StaticHandle, Simulation.Statics).Pose.Position :
            new BodyReference(firstCollidableInPair.BodyHandle, Simulation.Bodies).Pose.Position);
        particle.Age = 0;
        particle.Normal = contactNormal;
    }

    bool PreviousContainsTouchingFeatureId(ref PairCollision pair, int featureId)
    {
        for (int i = 0; i < pair.Contacts.Count; ++i)
        {
            if (pair.Contacts.GetFeatureId(i) == featureId && pair.Contacts.GetDepth(ref pair.Contacts, i) >= 0)
                return true;
        }
        return false;
    }

    public override void Update(Window window, Camera camera, Input input, float dt)
    {
        //base.Update includes a call to the Simulation.Timestep. We want to prepare the worker caches and flush them after the timestep completes.
        //(These could be hooked onto events exposed by the simulation.Timestepper, like the CollisionEvents demo does, but this demo tries to be a little less magic.
        collisionTracker.PrepareForNextTimestep();
        base.Update(window, camera, input, dt);
        collisionTracker.Flush();

        //Now analyze the contacts we've collected.
        for (int trackedIndex = 0; trackedIndex < collisionTracker.Tracked.Count; ++trackedIndex)
        {
            //We do a somewhat questionable previous test here. All contacts are stored in lists, so we enumerate all previous collisions.
            //For objects with relatively few collisions, this is perfectly fine (and actually near optimal).
            //But if a single object has thousands of collisions, this is going to scale pretty poorly.
            //The demo doesn't worry about this for simplicity reasons, but you could use a dictionary or other more suitable structure.
            ref var others = ref collisionTracker.Tracked.Values[trackedIndex];
            var self = collisionTracker.Tracked.Keys[trackedIndex];
            for (int otherIndex = 0; otherIndex < others.Collisions.Count; ++otherIndex)
            {
                int indexInPrevious = -1;
                ref var other = ref others.Collisions[otherIndex];
                for (int k = 0; k < others.PreviousCollisions.Count; ++k)
                {
                    if (others.PreviousCollisions[k].Other == others.Collisions[otherIndex].Other)
                    {
                        indexInPrevious = k;
                        break;
                    }
                }
                if (indexInPrevious >= 0)
                {
                    //There exists a previous collision.
                    ref var previous = ref others.PreviousCollisions[indexInPrevious];
                    for (int i = 0; i < other.Contacts.Count; ++i)
                    {
                        if (other.Contacts.GetDepth(ref other.Contacts, i) >= 0)
                        {
                            //This contact is touching. Does there exist a contact with the same feature id that was touching in the previous timestep?
                            if (!PreviousContainsTouchingFeatureId(ref previous, other.Contacts.GetFeatureId(i)))
                                AddParticle(other.Contacts.GetOffset(ref other.Contacts, i), other.Contacts.GetNormal(ref other.Contacts, i), other.OtherIsPairA ? other.Other.Collidable : self.Collidable);
                        }
                    }
                }
                else
                {
                    //No previous collision, so all contacts are new.
                    for (int i = 0; i < other.Contacts.Count; ++i)
                    {
                        AddParticle(other.Contacts.GetOffset(ref other.Contacts, i), other.Contacts.GetNormal(ref other.Contacts, i), other.OtherIsPairA ? other.Other.Collidable : self.Collidable);
                    }
                }
            }
        }

        //Age and scoot the particles we created for new contacts for the animation.
        for (int i = particles.Count - 1; i >= 0; --i)
        {
            ref var particle = ref particles[i];
            particle.Age += dt;
            if (particle.Age > 0.7325f)
            {
                particles.FastRemoveAt(i);
            }
            else
            {
                particle.Position += particle.Normal * (2 * dt);
            }

        }
    }

    public override void Render(Renderer renderer, Camera camera, Input input, TextBuilder text, Font font)
    {
        for (int i = particles.Count - 1; i >= 0; --i)
        {
            ref var particle = ref particles[i];
            var radius = particle.Age * (particle.Age * (0.135f - 2.7f * particle.Age) + 1.35f);
            var pose = new RigidPose(particle.Position);
            renderer.Shapes.AddShape(new Sphere(radius), Simulation.Shapes, pose, new Vector3(0, 1, 0));
        }

        var resolution = renderer.Surface.Resolution;
        renderer.TextBatcher.Write(text.Clear().Append("TBA!"), new Vector2(16, resolution.Y - 80), 16, Vector3.One, font);

        base.Render(renderer, camera, input, text, font);
    }
}
