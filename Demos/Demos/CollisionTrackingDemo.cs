using System;
using System.Numerics;
using BepuUtilities;
using BepuPhysics;
using DemoContentLoader;
using DemoRenderer;
using BepuPhysics.Collidables;
using DemoUtilities;
using DemoRenderer.UI;
using BepuPhysics.CollisionDetection;
using BepuUtilities.Collections;
using BepuUtilities.Memory;
using System.Runtime.CompilerServices;
using BepuPhysics.Constraints;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Demos.Demos;

/// <summary>
/// Shows how to store out collision information provided in <see cref="INarrowPhaseCallbacks"/> for later analysis, 
/// and how to use it to implement something like collision events without imposing the weird control flow that events imply.
/// </summary>
/// <remarks>
/// This implementation focuses more on simplicity than performance.
/// It's not too slow, but if you run into bottlenecks with tens of thousands of bodies with tracked collisions, be advised that you can make it faster!
/// </remarks>
public class CollisionTrackingDemo : Demo
{
    /// <summary>
    /// Refers to a collidable, or a child within a collidable.
    /// </summary>
    /// <remarks>This contact tracker allows the children of compounds to be tracked, so it's not enough to only store a <see cref="CollidableReference"/>.
    /// That would only permit top-level pair analysis.</remarks>
    public struct ContactSource : IEqualityComparerRef<ContactSource>, IEquatable<ContactSource>
    {
        /// <summary>
        /// Collidable associated with this listener.
        /// </summary>
        public CollidableReference Collidable;
        /// <summary>
        /// Child index within the collidable associated with this listener, if any. -1 if the listener is associated with the entire collidable.
        /// </summary>
        public int ChildIndex;

        public bool Equals(ref ContactSource a, ref ContactSource b) => a.Collidable == b.Collidable && a.ChildIndex == b.ChildIndex;
        public int Hash(ref ContactSource item) => (int)(item.Collidable.Packed ^ uint.RotateLeft((uint)item.ChildIndex, 16));
        public bool Equals(ContactSource other) => Equals(ref this, ref other);
        public override bool Equals(object obj) => obj is ContactSource source && Equals(source);
        public override int GetHashCode() => Hash(ref this);
        public static bool operator ==(ContactSource left, ContactSource right) => left.Equals(right);
        public static bool operator !=(ContactSource left, ContactSource right) => !(left == right);

        public static implicit operator ContactSource(CollidableReference collidable) => new() { Collidable = collidable, ChildIndex = -1 };
    }

    /// <summary>
    /// Stores contacts generated by the narrow phase for a pair.
    /// </summary>
    public struct PairCollision
    {
        /// <summary>
        /// Stores whether the 'other' collidable (the one that isn't the current tracked object) is stored in the first slot of the collision pair. True if it is, false if it isn't.
        /// This matters for interpreting the contact data: by convention, the contact offset is relative to collidable A, and the normal points from B to A.
        /// </summary>
        public bool OtherIsPairA;
        /// <summary>
        /// True if the current front buffer is <see cref="A"/>, otherwise the front buffer is <see cref="B"/>.
        /// </summary>
        public bool AIsFrontBuffer;

        /// <summary>
        /// One of two contact buffers in the collision. This may be either the front or back buffer depending on the value of <see cref="AIsFrontBuffer"/>.
        /// </summary>
        public NonconvexContactManifold A;
        /// <summary>
        /// One of two contact buffers in the collision. This may be either the front or back buffer depending on the value of <see cref="AIsFrontBuffer"/>.
        /// </summary>
        public NonconvexContactManifold B;

        /// <summary>
        /// Gets the contacts generated by the narrow phase in the latest update affecting this pair.
        /// </summary>
        /// <remarks>We're making use of the <see cref="NonconvexContactManifold"/> type here because it's able to store both nonconvex manifolds and convex manifolds.
        /// Within the callbacks, we convert convex manifolds into nonconvex manifolds by rearranging data; that way, post-analysis doesn't need to worry about the manifold type.</remarks>
        public static ref NonconvexContactManifold GetContacts(ref PairCollision pair) => ref pair.AIsFrontBuffer ? ref pair.A : ref pair.B;
        /// <summary>
        /// Gets the contacts generated by the narrow phase in the update before last affecting this pair.
        /// </summary>
        public static ref NonconvexContactManifold GetPreviousContacts(ref PairCollision pair) => ref pair.AIsFrontBuffer ? ref pair.B : ref pair.A;
    }



    /// <summary>
    /// Tracks collisions for a set of collidables (or their children).
    /// </summary>
    public class CollisionTracker
    {
        IThreadDispatcher dispatcher;
        BufferPool pool;
        Simulation simulation;

        public CollisionTracker(BufferPool pool, IThreadDispatcher dispatcher)
        {
            this.pool = pool;
            this.dispatcher = dispatcher;
            Tracked = new QuickDictionary<ContactSource, TrackedPairs, ContactSource>(16, pool);
        }

        public void Initialize(Simulation simulation)
        {
            //The CollisionTracker is created before the Simulation in this demo because we're passing it in as a part of the INarrowPhaseCallbacks.
            //So, we let the callbacks initialize the simulation reference!
            this.simulation = simulation;
        }

        /// <summary>
        /// Defines how a tracked object should handle pair tracking when it (or the other collidable in the pair) is sleeping/static.
        /// </summary>
        /// <remarks>
        /// This complexity arises from the fact that collision pairs between sleeping bodies do not invoke narrow phase callbacks, because they are never examined.
        /// The broad phase will only ever emit pair tests for pairs that contain at least one wakeful body.
        /// This enumeration defines the ways in which the collision tracker can handle this situation.
        /// </remarks>
        public enum SleepBehavior
        {
            /// <summary>
            /// If the tracked object is a sleeping body, all of its associated pairs are considered paused in time and will not be flipped/cleared.
            /// Pairs with no wakeful bodies will then still have tracked contacts even though sleeping pairs do not invoke narrow phase callbacks.
            /// <para/>
            /// Any contacts detected between the sleeping body and other wakeful bodies will not be reported unless those contacts cause the sleeping body to wake up.
            /// <para/>
            /// Static bodies 
            /// <para/>
            /// This is very cheap and simple.
            /// </summary>
            PauseTrackingForSleepingBodies,
            /// <summary>
            /// Every frame, regardless of whether the tracked object is awake or static, the collision tracker will flip the previous/current buffers and clear the newly-current buffer before flushing new contacts.
            /// If the tracked collidable is static or sleeping, the incoming contacts will only contain contacts found from wakeful bodies interacting with the tracked object.
            /// If neither collidable in a pair is awake, no new contacts will be reported, and so the tracker will contain no contacts for the pair even if it had contacts prior to sleeping.
            /// <para/>
            /// This is very cheap and simple.
            /// </summary>
            AlwaysClear,
        }


        public struct TrackedPairs
        {
            /// <summary>
            /// Holds all pairs associated with a tracked object. Keys are the 'other' collidable in the pair- whatever collidable isn't the tracked object.
            /// </summary>
            public QuickDictionary<ContactSource, PairCollision, ContactSource> Pairs;

            public TrackedPairs(BufferPool pool)
            {
                //For simplicity, we'll initialize all the contact storage with a fixed size. It'll grow over time if more collisions per tracked object are detected.
                //Some kind of compaction would be easy to add- just iterate over all tracked objects and call Compact.
                //(Or just part of them, incrementally! Probably better to avoid excess resizes!)
                Pairs = new QuickDictionary<ContactSource, PairCollision, ContactSource>(16, pool);
            }


            public void Dispose(BufferPool pool)
            {
                Pairs.Dispose(pool);
            }
        }

        /// <summary>
        /// Maps tracked objects to the contacts associated with them.
        /// </summary>
        public QuickDictionary<ContactSource, TrackedPairs, ContactSource> Tracked;

        /// <summary>
        /// Adds a collidable (or its child) to the collision tracker. Collisions associated with it will be included for queries.
        /// </summary>
        /// <param name="target">Collidable (or child) to track.</param>
        /// <exception cref="ArgumentException">Triggered if the collidable or child is already present.</exception>
        public void Track(ContactSource target)
        {
            if (Tracked.ContainsKey(target))
                throw new ArgumentException("Object already tracked.");
            Tracked.Add(target, new TrackedPairs(pool), pool);
        }

        /// <summary>
        /// Removes a listener from the tracker.
        /// </summary>
        /// <param name="target">Collidable (or child) to untrack.</param>
        /// <exception cref="ArgumentException">Triggered if the collidable or child is not present.</exception>
        public void Untrack(ContactSource target)
        {
            if (!Tracked.ContainsKey(target))
                throw new ArgumentException("Object is not tracked.");
            Tracked.GetTableIndices(ref target, out var tableIndex, out var elementIndex);
            Tracked.Values[elementIndex].Dispose(pool);
            Tracked.FastRemove(tableIndex, elementIndex);
        }

        //The INarrowPhaseCallbacks are invoked from multiple threads and are performance sensitive.
        //We want to do as little as possible, so rather than locking and trying to modify the final storage directly,
        //just create per-worker caches that get flushed at the end.

        /// <summary>
        /// Stores a single tracked result in a worker cache to later be flushed.
        /// </summary>
        struct WorkerPairContacts
        {
            public ContactSource Self;
            public ContactSource Other;
            public bool OtherIsAInPair;
            public NonconvexContactManifold Contacts;
        }

        /// <summary>
        /// Stores contacts for listeners reported by callbacks to a particular thread.
        /// </summary>
        Buffer<QuickList<WorkerPairContacts>> workerCaches;

        public void PrepareForNextTimestep()
        {
            workerCaches = new Buffer<QuickList<WorkerPairContacts>>(dispatcher.ThreadCount, pool);
            for (int i = 0; i < workerCaches.Length; ++i)
            {
                workerCaches[i] = new QuickList<WorkerPairContacts>(512, dispatcher.GetThreadMemoryPool(i));
            }
        }

        /// <summary>
        /// Flushes all collisions found in the previous timestep into efficient storage for queries.
        /// </summary>
        public void Flush()
        {
            //Flip the caches for each listener and clear out the now-current set for accumulation.
            for (int i = 0; i < Tracked.Count; ++i)
            {
                ref var pairs = ref Tracked.Values[i].Pairs;
                var collidable = Tracked.Keys[i].Collidable;
                if (collidable.Mobility != CollidableMobility.Static && simulation.Bodies[collidable.BodyHandle].Awake)
                {                    
                    //There is no need to consider the sleeping state of the other body when the tracked object is awake; flip all pairs and clear the new front buffer.
                    for (int j = 0; j < pairs.Count; ++j)
                    {
                        ref var pair = ref pairs.Values[j];
                        pair.AIsFrontBuffer = !pair.AIsFrontBuffer;
                        PairCollision.GetContacts(ref pair).Count = 0;
                    }
                }
                else
                {
                    //The tracked object is either sleeping or static.
                    //Any pair involving a wakeful body must be flipped and cleared. Any pair involving a sleeping body or a static doesn't.
                    //(Note that the broad phase will never report a pair containing only sleeping bodies or statics; those both live in the static tree, and it is not tested with itself.)
                    for (int j = 0; j < pairs.Count; ++j)
                    {
                        var other = pairs.Keys[j];
                        if (other.Collidable.Mobility != CollidableMobility.Static && simulation.Bodies[other.Collidable.BodyHandle].Awake)
                        {
                            //Wakeful body! Flip and clear.
                            ref var pair = ref pairs.Values[j];
                            pair.AIsFrontBuffer = !pair.AIsFrontBuffer;
                            PairCollision.GetContacts(ref pair).Count = 0;
                        }
                    }
                }
            }

            //Flush the worker caches into the main storage and dispose the caches.
            for (int i = 0; i < workerCaches.Length; ++i)
            {
                ref var cache = ref workerCaches[i];
                for (int j = 0; j < cache.Count; ++j)
                {
                    ref var entry = ref cache[j];
                    Tracked.GetTableIndices(ref entry.Self, out _, out var elementIndex);
                    Tracked.Values[elementIndex].Pairs.Add(entry.Collision., pool);
                }
                //The worker cache memory must be returned to the thread pool, not the main pool!
                cache.Dispose(dispatcher.GetThreadMemoryPool(i));
            }
            workerCaches.Dispose(pool);
        }

        private void ReportContacts<TContacts>(int workerIndex, ContactSource self, ContactSource other, bool otherIsA, ref TContacts contacts) where TContacts : unmanaged, IContactManifold<TContacts>
        {
            if (Tracked.ContainsKey(self))
            {
                //A is a listener, add it.            
                ref var pairContacts = ref workerCaches[workerIndex].Allocate(dispatcher.GetThreadMemoryPool(workerIndex));
                pairContacts.Self = self;
                pairContacts.Other = other;
                pairContacts.OtherIsAInPair = otherIsA;
                PairCollision.GetContacts
                if (typeof(TContacts) == typeof(ConvexContactManifold)) //This is a JIT-time constant.
                {
                    //The pairContacts representation just uses a NonconvexContactManifold for simplicity- we can just rearrange convex contacts to fit.
                    //(Without doing this, the post-analysis would constantly have to check an "IsConvex" flag and so forth. It would be quite stinky.)
                    ref var convex = ref Unsafe.As<TContacts, ConvexContactManifold>(ref contacts);
                    for (int i = 0; i < contacts.Count; ++i)
                    {
                        ref var targetContact = ref Unsafe.Add(ref pairContacts.Contacts.Contact0, i);
                        convex.GetContact(i, out targetContact.Offset, out targetContact.Normal, out targetContact.Depth, out targetContact.FeatureId);
                    }
                    pairContacts.Contacts.Count = contacts.Count;
                    pairContacts.Contacts.OffsetB = convex.OffsetB;
                }
                else
                {
                    pairContacts.Contacts = Unsafe.As<TContacts, NonconvexContactManifold>(ref contacts);
                }
            }
        }

        /// <summary>
        /// Notifies the tracker of a collision between collidable children.
        /// </summary>
        /// <param name="collidableA">First collidable in the pair.</param>
        /// <param name="childIndexA">Child index associated with the first collidable in the pair.</param>
        /// <param name="collidableB">Second collidable in the pair.</param>
        /// <param name="childIndexB">Child index associated with the second collidable in the pair.</param>
        /// <param name="workerIndex">Index of the worker invoking this callback.</param>
        /// <param name="contacts">Contacts reported in the callback.</param>
        public void ReportChildContacts(CollidableReference collidableA, int childIndexA, CollidableReference collidableB, int childIndexB, int workerIndex, ref ConvexContactManifold contacts)
        {
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            var a = new ContactSource { Collidable = collidableA, ChildIndex = childIndexA };
            var b = new ContactSource { Collidable = collidableB, ChildIndex = childIndexB };
            ReportContacts(workerIndex, a, b, false, ref contacts);
            ReportContacts(workerIndex, b, a, true, ref contacts);
        }


        /// <summary>
        /// Notifies the tracker of a collision between collidables.
        /// </summary>
        /// <typeparam name="TManifold">Type of the manifold being reported.</typeparam>
        /// <param name="collidableA">First collidable in the pair.</param>
        /// <param name="collidableB">Second collidable in the pair.</param>
        /// <param name="workerIndex">Index of the worker invoking this callback.</param>
        /// <param name="contacts">Contacts reported in the callback.</param>
        public void ReportContacts<TManifold>(CollidableReference collidableA, CollidableReference collidableB, int workerIndex, ref TManifold contacts) where TManifold : unmanaged, IContactManifold<TManifold>
        {
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            Debug.Assert(workerCaches.Allocated, "The worker caches must be allocated in order to report contacts. Make sure PrepareForNextTimestep was called.");
            var a = new ContactSource { Collidable = collidableA, ChildIndex = -1 };
            var b = new ContactSource { Collidable = collidableB, ChildIndex = -1 };
            ReportContacts(workerIndex, a, b, false, ref contacts);
            ReportContacts(workerIndex, b, a, true, ref contacts);
        }

    }

    /// <summary>
    /// Callbacks invoked by the simulation's narrow phase.
    /// In this demo, we'll collect all contact data associated with tracked objects for later processing.
    /// </summary>
    public unsafe struct CollisionTrackingCallbacks : INarrowPhaseCallbacks
    {
        CollisionTracker collisionTracker;
        public CollisionTrackingCallbacks(CollisionTracker collisionTracker)
        {
            this.collisionTracker = collisionTracker;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AllowContactGeneration(int workerIndex, CollidableReference a, CollidableReference b, ref float speculativeMargin)
        {
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AllowContactGeneration(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB)
        {
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe bool ConfigureContactManifold<TManifold>(int workerIndex, CollidablePair pair, ref TManifold manifold, out PairMaterialProperties pairMaterial) where TManifold : unmanaged, IContactManifold<TManifold>
        {
            pairMaterial.FrictionCoefficient = 1f;
            pairMaterial.MaximumRecoveryVelocity = 2f;
            pairMaterial.SpringSettings = new SpringSettings(30, 1);
            collisionTracker.ReportContacts(pair.A, pair.B, workerIndex, ref manifold);
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ConfigureContactManifold(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB, ref ConvexContactManifold manifold)
        {
            collisionTracker.ReportChildContacts(pair.A, childIndexA, pair.B, childIndexB, workerIndex, ref manifold);
            return true;
        }

        public void Initialize(Simulation simulation)
        {
            collisionTracker.Initialize(simulation);
        }

        public void Dispose()
        {
        }

    }

    /// <summary>
    /// Tracks a particle created by a collision.
    /// </summary>
    struct ContactResponseParticle
    {
        public Vector3 Position;
        public float Age;
        public Vector3 Normal;
    }
    QuickList<ContactResponseParticle> particles;

    CollisionTracker collisionTracker;


    public override void Initialize(ContentArchive content, Camera camera)
    {
        camera.Position = new Vector3(0, 8, -20);
        camera.Yaw = MathHelper.Pi;

        particles = new QuickList<ContactResponseParticle>(8, BufferPool);

        collisionTracker = new CollisionTracker(BufferPool, ThreadDispatcher);
        Simulation = Simulation.Create(BufferPool, new CollisionTrackingCallbacks(collisionTracker), new DemoPoseIntegratorCallbacks(new Vector3(0, -10, 0)), new SolveDescription(8, 1));


        var listenedBody1 = Simulation.Bodies.Add(BodyDescription.CreateConvexDynamic(new Vector3(0, 5, 0), 1, Simulation.Shapes, new Box(1, 2, 3)));
        collisionTracker.Track(Simulation.Bodies[listenedBody1].CollidableReference);

        var listenedBody2 = Simulation.Bodies.Add(BodyDescription.CreateConvexDynamic(new Vector3(0.5f, 10, 0), 1, Simulation.Shapes, new Capsule(0.25f, 0.7f)));
        collisionTracker.Track(Simulation.Bodies[listenedBody2].CollidableReference);


        Simulation.Statics.Add(new StaticDescription(new Vector3(0, -0.5f, 0), Simulation.Shapes.Add(new Box(30, 1, 30))));
        Simulation.Statics.Add(new StaticDescription(new Vector3(0, 3, 15), Simulation.Shapes.Add(new Box(30, 5, 1))));
    }

    static bool IsTouching(NonconvexContactManifold contacts)
    {
        for (int i = 0; i < contacts.Count; ++i)
        {
            //This may look a bit odd: it's a legacy issue from before static abstracts existed. Expect it to change soon!
            if (contacts.GetDepth(ref contacts, i) >= 0)
            {
                return true;
            }
        }
        return false;
    }

    void AddParticle(Vector3 contactOffset, Vector3 contactNormal, CollidableReference firstCollidableInPair)
    {
        ref var particle = ref particles.Allocate(BufferPool);

        //Contact data is calibrated according to the order of the pair, so using A's position is important.
        particle.Position = contactOffset + (firstCollidableInPair.Mobility == CollidableMobility.Static ?
            new StaticReference(firstCollidableInPair.StaticHandle, Simulation.Statics).Pose.Position :
            new BodyReference(firstCollidableInPair.BodyHandle, Simulation.Bodies).Pose.Position);
        particle.Age = 0;
        particle.Normal = contactNormal;
    }

    bool PreviousContainsTouchingFeatureId(ref PairCollision pair, int featureId)
    {
        for (int i = 0; i < pair.Contacts.Count; ++i)
        {
            if (pair.Contacts.GetFeatureId(i) == featureId && pair.Contacts.GetDepth(ref pair.Contacts, i) >= 0)
                return true;
        }
        return false;
    }

    public override void Update(Window window, Camera camera, Input input, float dt)
    {
        //base.Update includes a call to the Simulation.Timestep. We want to prepare the worker caches and flush them after the timestep completes.
        //(These could be hooked onto events exposed by the simulation.Timestepper, like the CollisionEvents demo does, but this demo tries to be a little less magic.
        collisionTracker.PrepareForNextTimestep();
        base.Update(window, camera, input, dt);
        collisionTracker.Flush();

        //Now analyze the contacts we've collected.
        for (int trackedIndex = 0; trackedIndex < collisionTracker.Tracked.Count; ++trackedIndex)
        {
            //We do a somewhat questionable previous test here. All contacts are stored in lists, so we enumerate all previous collisions.
            //For objects with relatively few collisions, this is perfectly fine (and actually near optimal).
            //But if a single object has thousands of collisions, this is going to scale pretty poorly.
            //The demo doesn't worry about this for simplicity reasons, but you could use a dictionary or other more suitable structure.
            ref var others = ref collisionTracker.Tracked.Values[trackedIndex];
            var self = collisionTracker.Tracked.Keys[trackedIndex];
            for (int otherIndex = 0; otherIndex < others.Collisions.Count; ++otherIndex)
            {
                int indexInPrevious = -1;
                ref var other = ref others.Collisions[otherIndex];
                for (int k = 0; k < others.PreviousCollisions.Count; ++k)
                {
                    if (others.PreviousCollisions[k].Other == others.Collisions[otherIndex].Other)
                    {
                        indexInPrevious = k;
                        break;
                    }
                }
                if (indexInPrevious >= 0)
                {
                    //There exists a previous collision.
                    ref var previous = ref others.PreviousCollisions[indexInPrevious];
                    for (int i = 0; i < other.Contacts.Count; ++i)
                    {
                        if (other.Contacts.GetDepth(ref other.Contacts, i) >= 0)
                        {
                            //This contact is touching. Does there exist a contact with the same feature id that was touching in the previous timestep?
                            if (!PreviousContainsTouchingFeatureId(ref previous, other.Contacts.GetFeatureId(i)))
                                AddParticle(other.Contacts.GetOffset(ref other.Contacts, i), other.Contacts.GetNormal(ref other.Contacts, i), other.OtherIsPairA ? other.Other.Collidable : self.Collidable);
                        }
                    }
                }
                else
                {
                    //No previous collision, so all contacts are new.
                    for (int i = 0; i < other.Contacts.Count; ++i)
                    {
                        AddParticle(other.Contacts.GetOffset(ref other.Contacts, i), other.Contacts.GetNormal(ref other.Contacts, i), other.OtherIsPairA ? other.Other.Collidable : self.Collidable);
                    }
                }
            }
        }

        //Age and scoot the particles we created for new contacts for the animation.
        for (int i = particles.Count - 1; i >= 0; --i)
        {
            ref var particle = ref particles[i];
            particle.Age += dt;
            if (particle.Age > 0.7325f)
            {
                particles.FastRemoveAt(i);
            }
            else
            {
                particle.Position += particle.Normal * (2 * dt);
            }

        }
    }

    public override void Render(Renderer renderer, Camera camera, Input input, TextBuilder text, Font font)
    {
        for (int i = particles.Count - 1; i >= 0; --i)
        {
            ref var particle = ref particles[i];
            var radius = particle.Age * (particle.Age * (0.135f - 2.7f * particle.Age) + 1.35f);
            var pose = new RigidPose(particle.Position);
            renderer.Shapes.AddShape(new Sphere(radius), Simulation.Shapes, pose, new Vector3(0, 1, 0));
        }

        var resolution = renderer.Surface.Resolution;
        renderer.TextBatcher.Write(text.Clear().Append("TBA!"), new Vector2(16, resolution.Y - 80), 16, Vector3.One, font);

        base.Render(renderer, camera, input, text, font);
    }
}
